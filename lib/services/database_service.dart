import 'package:hive_flutter/hive_flutter.dart';
import 'package:uuid/uuid.dart';
import '../models/user_profile.dart';
import '../models/coffee_bag.dart';
import '../models/cup.dart';
import '../models/shared_cup.dart';
import '../models/equipment_setup.dart';
import '../models/drink_recipe.dart';
import '../utils/constants.dart';

/// Local database service using Hive for offline-first storage.
///
/// This is the core data persistence layer for BrewLog. All data is stored
/// locally first in Hive (embedded NoSQL database), enabling full offline
/// functionality. Firebase sync is optional for premium users.
///
/// **Architecture Pattern:** Singleton
///
/// **Managed Hive Boxes:**
/// - `user` - Single [UserProfile] (stored as 'current_user')
/// - `bags` - All [CoffeeBag] instances
/// - `cups` - All [Cup] instances
/// - `shared_cups` - All [SharedCup] instances from QR imports
/// - `equipment` - All [EquipmentSetup] configurations
/// - `drink_recipes` - All [DrinkRecipe] instances
///
/// **Key Responsibilities:**
/// - CRUD operations for all models
/// - Automatic statistics calculation and updates
/// - Relationship management (e.g., deleting bag deletes its cups)
/// - Default user creation on first run
/// - Transaction-like operations (statistics stay consistent)
///
/// **Usage:**
/// ```dart
/// final db = DatabaseService();
/// await db.initialize();  // Call once at app startup
///
/// // CRUD operations
/// final bags = db.getAllBags();
/// await db.createCup(newCup);  // Auto-updates bag & user stats
/// await db.deleteBag(bagId);   // Cascade deletes all cups
/// ```
///
/// **Important Notes:**
/// - Uses JSON serialization until Hive adapters are generated
/// - Statistics update automatically on cup create/update/delete
/// - All methods are synchronous except for Hive I/O operations
/// - Thread-safe due to Hive's internal locking
///
/// **See Also:**
/// - [FirebaseService] for cloud sync operations
/// - [CODEBASE_GUIDE.md] section "Services Layer"
class DatabaseService {
  static const String _userBoxName = 'user';
  static const String _bagsBoxName = 'bags';
  static const String _cupsBoxName = 'cups';
  static const String _sharedCupsBoxName = 'shared_cups';
  static const String _equipmentBoxName = 'equipment';
  static const String _drinkRecipesBoxName = 'drink_recipes';

  final _uuid = const Uuid();

  // Hive boxes - using dynamic boxes until adapters are generated
  // After running build_runner, change these to typed boxes for better performance
  late Box _userBox;
  late Box _bagsBox;
  late Box _cupsBox;
  late Box _sharedCupsBox;
  late Box _equipmentBox;
  late Box _drinkRecipesBox;

  // Singleton pattern
  static final DatabaseService _instance = DatabaseService._internal();
  factory DatabaseService() => _instance;
  DatabaseService._internal();

  bool _isInitialized = false;

  /// Initialize Hive and open boxes
  Future<void> initialize() async {
    if (_isInitialized) return; // Prevent double initialization

    // NOTE: Hive.initFlutter() is called in main.dart before this
    // Do not call it again here to avoid conflicts

    // Register adapters (generated by build_runner)
    // Note: These will be generated when you run build_runner
    // Hive.registerAdapter(UserProfileAdapter());
    // Hive.registerAdapter(UserStatsAdapter());
    // Hive.registerAdapter(CoffeeBagAdapter());
    // Hive.registerAdapter(CupAdapter());
    // Hive.registerAdapter(SharedCupAdapter());

    // Using dynamic boxes until adapters are generated
    // After running build_runner and registering adapters, change to typed boxes:
    // _userBox = await Hive.openBox<UserProfile>(_userBoxName);
    _userBox = await Hive.openBox(_userBoxName);
    _bagsBox = await Hive.openBox(_bagsBoxName);
    _cupsBox = await Hive.openBox(_cupsBoxName);
    _sharedCupsBox = await Hive.openBox(_sharedCupsBoxName);
    _equipmentBox = await Hive.openBox(_equipmentBoxName);
    _drinkRecipesBox = await Hive.openBox(_drinkRecipesBoxName);

    // Create default user if doesn't exist
    if (_userBox.isEmpty) {
      await _createDefaultUser();
    }

    _isInitialized = true;
  }

  /// Create default free user
  Future<void> _createDefaultUser() async {
    final user = UserProfile(
      id: _uuid.v4(),
      username: null, // No default username - prompt user to create one
      isPaid: false,
      isAdmin: false,
      ratingScaleIndex: RatingScale.oneToFive.index,
      viewPreferenceIndex: ViewPreference.grid.index,
    );
    // Store as JSON until adapters are generated
    await _userBox.put('current_user', user.toJson());
  }

  // ============================================================================
  // USER OPERATIONS
  // ============================================================================

  /// Get current user profile
  UserProfile? getCurrentUser() {
    final json = _userBox.get('current_user');
    if (json == null) return null;
    return UserProfile.fromJson(Map<String, dynamic>.from(json as Map));
  }

  /// Update user profile
  Future<void> updateUser(UserProfile user) async {
    user.touch();
    // Store as JSON until adapters are generated
    await _userBox.put('current_user', user.toJson());
  }

  /// Update user stats
  Future<void> updateUserStats(UserStats stats) async {
    final user = getCurrentUser();
    if (user != null) {
      user.stats = stats;
      await updateUser(user);
    }
  }

  /// Recalculate user statistics from actual data
  Future<UserStats> recalculateUserStats() async {
    final newStats = UserStats();

    // Count total bags
    final bags = getAllBags();
    newStats.totalBagsPurchased = bags.length;

    // Iterate through all cups to calculate stats
    final allCups = _cupsBox.values
        .map((json) => Cup.fromJson(Map<String, dynamic>.from(json as Map)))
        .toList();

    for (final cup in allCups) {
      newStats.addCup(
        brewType: cup.brewType,
        gramsUsed: cup.gramsUsed,
        mlConsumed: cup.finalVolumeMl,
      );
    }

    return newStats;
  }

  // ============================================================================
  // COFFEE BAG OPERATIONS
  // ============================================================================

  /// Get all bags for current user
  List<CoffeeBag> getAllBags() {
    final user = getCurrentUser();
    if (user == null) return [];

    return _bagsBox.values
        .map((json) => CoffeeBag.fromJson(Map<String, dynamic>.from(json as Map)))
        .where((bag) => bag.userId == user.id)
        .toList()
      ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
  }

  /// Get bag by ID
  CoffeeBag? getBag(String bagId) {
    final json = _bagsBox.get(bagId);
    if (json == null) return null;
    return CoffeeBag.fromJson(Map<String, dynamic>.from(json as Map));
  }

  /// Create new bag
  Future<String> createBag(CoffeeBag bag) async {
    // Store as JSON until adapters are generated
    await _bagsBox.put(bag.id, bag.toJson());

    // Update user stats
    final user = getCurrentUser();
    if (user != null) {
      user.stats.totalBagsPurchased++;
      await updateUser(user);
    }

    return bag.id;
  }

  /// Update existing bag
  Future<void> updateBag(CoffeeBag bag) async {
    bag.touch();
    // Store as JSON until adapters are generated
    await _bagsBox.put(bag.id, bag.toJson());
  }

  /// Delete bag and all its cups
  Future<void> deleteBag(String bagId) async {
    // Delete all cups in this bag
    final cups = getCupsForBag(bagId);
    for (final cup in cups) {
      await deleteCup(cup.id);
    }

    // Delete the bag
    await _bagsBox.delete(bagId);

    // Update user stats
    final user = getCurrentUser();
    if (user != null && user.stats.totalBagsPurchased > 0) {
      user.stats.totalBagsPurchased--;
      await updateUser(user);
    }
  }

  /// Recalculate bag statistics based on its cups
  Future<void> recalculateBagStats(String bagId) async {
    final bag = getBag(bagId);
    if (bag == null) return;

    final cups = getCupsForBag(bagId);

    // Calculate average score
    final scores = cups
        .where((cup) => cup.score1to5 != null)
        .map((cup) => cup.score1to5!)
        .toList();

    bag.totalCups = cups.length;
    bag.avgScore = scores.isEmpty
        ? null
        : scores.reduce((a, b) => a + b) / scores.length;

    // Find best cup
    final bestCup = cups
        .where((cup) => cup.isBest)
        .firstOrNull;
    bag.bestCupId = bestCup?.id;

    await updateBag(bag);
  }

  // ============================================================================
  // CUP OPERATIONS
  // ============================================================================

  /// Get all cups for a bag
  List<Cup> getCupsForBag(String bagId) {
    return _cupsBox.values
        .map((json) => Cup.fromJson(Map<String, dynamic>.from(json as Map)))
        .where((cup) => cup.bagId == bagId)
        .toList()
      ..sort((a, b) => b.createdAt.compareTo(a.createdAt));
  }

  /// Get cup by ID
  Cup? getCup(String cupId) {
    final json = _cupsBox.get(cupId);
    if (json == null) return null;
    return Cup.fromJson(Map<String, dynamic>.from(json as Map));
  }

  /// Create new cup
  Future<String> createCup(Cup cup) async {
    // Store as JSON until adapters are generated
    await _cupsBox.put(cup.id, cup.toJson());

    // Update user stats
    final user = getCurrentUser();
    if (user != null) {
      user.stats.addCup(
        brewType: cup.brewType,
        gramsUsed: cup.gramsUsed,
        mlConsumed: cup.finalVolumeMl,
      );
      await updateUser(user);
    }

    // Update bag stats
    await recalculateBagStats(cup.bagId);

    // Increment drink recipe usage count if recipe was used
    if (cup.drinkRecipeId != null) {
      await incrementDrinkRecipeUsage(cup.drinkRecipeId!);
    }

    return cup.id;
  }

  /// Update existing cup
  Future<void> updateCup(Cup cup) async {
    final oldCup = getCup(cup.id);

    cup.touch();
    // Store as JSON until adapters are generated
    await _cupsBox.put(cup.id, cup.toJson());

    // Update user stats if brew parameters changed
    if (oldCup != null) {
      final user = getCurrentUser();
      if (user != null) {
        // Remove old stats
        user.stats.removeCup(
          brewType: oldCup.brewType,
          gramsUsed: oldCup.gramsUsed,
          mlConsumed: oldCup.finalVolumeMl,
        );

        // Add new stats
        user.stats.addCup(
          brewType: cup.brewType,
          gramsUsed: cup.gramsUsed,
          mlConsumed: cup.finalVolumeMl,
        );

        await updateUser(user);
      }
    }

    // Update bag stats
    await recalculateBagStats(cup.bagId);

    // Increment drink recipe usage count if recipe was added or changed
    if (oldCup != null && cup.drinkRecipeId != null) {
      // Only increment if recipe was newly added or changed to a different recipe
      if (oldCup.drinkRecipeId != cup.drinkRecipeId) {
        await incrementDrinkRecipeUsage(cup.drinkRecipeId!);
      }
    }
  }

  /// Delete cup
  Future<void> deleteCup(String cupId) async {
    final cup = getCup(cupId);
    if (cup == null) return;

    // Update user stats
    final user = getCurrentUser();
    if (user != null) {
      user.stats.removeCup(
        brewType: cup.brewType,
        gramsUsed: cup.gramsUsed,
        mlConsumed: cup.finalVolumeMl,
      );
      await updateUser(user);
    }

    await _cupsBox.delete(cupId);

    // Update bag stats
    await recalculateBagStats(cup.bagId);
  }

  /// Copy cup (duplicate)
  Future<String> copyCup(String cupId) async {
    final original = getCup(cupId);
    if (original == null) throw Exception('Cup not found');

    final copy = original.copyWith();
    final newCup = Cup(
      id: _uuid.v4(),
      bagId: copy.bagId,
      userId: copy.userId,
      brewType: copy.brewType,
      grindLevel: copy.grindLevel,
      waterTempCelsius: copy.waterTempCelsius,
      gramsUsed: copy.gramsUsed,
      finalVolumeMl: copy.finalVolumeMl,
      brewTimeSeconds: copy.brewTimeSeconds,
      bloomTimeSeconds: copy.bloomTimeSeconds,
      score1to5: null, // Reset rating for new cup
      score1to10: null,
      score1to100: null,
      tastingNotes: null, // Reset notes
      flavorTags: List.from(copy.flavorTags),
      photoPaths: [], // Don't copy photos
      isBest: false,
      customTitle: copy.customTitle != null ? '${copy.customTitle} (Copy)' : null,
    );

    return await createCup(newCup);
  }

  /// Mark cup as best for its bag
  Future<void> markCupAsBest(String cupId) async {
    final cup = getCup(cupId);
    if (cup == null) return;

    // Unmark all other cups in this bag
    final allCups = getCupsForBag(cup.bagId);
    for (final c in allCups) {
      if (c.isBest && c.id != cupId) {
        c.isBest = false;
        // Store as JSON until adapters are generated
        await _cupsBox.put(c.id, c.toJson());
      }
    }

    // Mark this cup as best
    cup.isBest = true;
    await updateCup(cup);
  }

  // ============================================================================
  // SHARED CUP OPERATIONS
  // ============================================================================

  /// Get all shared cups for current user
  List<SharedCup> getSharedCups() {
    final user = getCurrentUser();
    if (user == null) return [];

    return _sharedCupsBox.values
        .map((json) => SharedCup.fromJson(Map<String, dynamic>.from(json as Map)))
        .where((shared) => shared.receivedByUserId == user.id)
        .toList()
      ..sort((a, b) => b.sharedAt.compareTo(a.sharedAt));
  }

  /// Add shared cup from QR code
  Future<String> addSharedCup(SharedCup sharedCup) async {
    // Store as JSON until adapters are generated
    await _sharedCupsBox.put(sharedCup.id, sharedCup.toJson());
    return sharedCup.id;
  }

  /// Delete shared cup
  Future<void> deleteSharedCup(String sharedCupId) async {
    await _sharedCupsBox.delete(sharedCupId);
  }

  /// Increment share count for a cup
  Future<void> incrementShareCount(String cupId) async {
    final cup = getCup(cupId);
    if (cup == null) return;

    cup.shareCount++;
    await updateCup(cup);
  }

  // ============================================================================
  // EQUIPMENT SETUP OPERATIONS
  // ============================================================================

  /// Get all equipment setups for current user
  List<EquipmentSetup> getAllEquipment() {
    final user = getCurrentUser();
    if (user == null) return [];

    return _equipmentBox.values
        .map((json) => EquipmentSetup.fromJson(Map<String, dynamic>.from(json as Map)))
        .where((equipment) => equipment.userId == user.id)
        .toList()
      ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
  }

  /// Get equipment setup by ID
  EquipmentSetup? getEquipment(String equipmentId) {
    final json = _equipmentBox.get(equipmentId);
    if (json == null) return null;
    return EquipmentSetup.fromJson(Map<String, dynamic>.from(json as Map));
  }

  /// Get default equipment setup for user
  EquipmentSetup? getDefaultEquipment() {
    final user = getCurrentUser();
    if (user == null) return null;

    try {
      return _equipmentBox.values
          .map((json) => EquipmentSetup.fromJson(Map<String, dynamic>.from(json as Map)))
          .firstWhere(
            (equipment) => equipment.userId == user.id && equipment.isDefault,
          );
    } catch (e) {
      return null;
    }
  }

  /// Create new equipment setup
  Future<String> createEquipment(EquipmentSetup equipment) async {
    // If this is the first equipment, make it default
    if (_equipmentBox.isEmpty) {
      equipment.isDefault = true;
    }

    // If marking as default, unmark all others
    if (equipment.isDefault) {
      await _unmarkAllEquipmentAsDefault(equipment.userId);
    }

    // Store as JSON until adapters are generated
    await _equipmentBox.put(equipment.id, equipment.toJson());
    return equipment.id;
  }

  /// Update existing equipment setup
  Future<void> updateEquipment(EquipmentSetup equipment) async {
    // If marking as default, unmark all others
    if (equipment.isDefault) {
      await _unmarkAllEquipmentAsDefault(equipment.userId);
    }

    equipment.touch();
    // Store as JSON until adapters are generated
    await _equipmentBox.put(equipment.id, equipment.toJson());
  }

  /// Delete equipment setup
  Future<void> deleteEquipment(String equipmentId) async {
    final equipment = getEquipment(equipmentId);
    if (equipment == null) return;

    await _equipmentBox.delete(equipmentId);

    // If this was the default, make another one default
    if (equipment.isDefault) {
      final remaining = getAllEquipment();
      if (remaining.isNotEmpty) {
        remaining.first.isDefault = true;
        await updateEquipment(remaining.first);
      }
    }
  }

  /// Set equipment as default
  Future<void> setEquipmentAsDefault(String equipmentId) async {
    final equipment = getEquipment(equipmentId);
    if (equipment == null) return;

    await _unmarkAllEquipmentAsDefault(equipment.userId);
    equipment.isDefault = true;
    await updateEquipment(equipment);
  }

  /// Unmark all equipment as default for a user
  Future<void> _unmarkAllEquipmentAsDefault(String userId) async {
    final allEquipment = _equipmentBox.values
        .map((json) => EquipmentSetup.fromJson(Map<String, dynamic>.from(json as Map)))
        .where((e) => e.userId == userId && e.isDefault);

    for (final equipment in allEquipment) {
      equipment.isDefault = false;
      // Store as JSON until adapters are generated
      await _equipmentBox.put(equipment.id, equipment.toJson());
    }
  }

  // ============================================================================
  // DRINK RECIPE OPERATIONS
  // ============================================================================

  /// Get all drink recipes for current user
  List<DrinkRecipe> getAllDrinkRecipes() {
    final user = getCurrentUser();
    if (user == null) return [];

    return _drinkRecipesBox.values
        .map((json) => DrinkRecipe.fromJson(Map<String, dynamic>.from(json as Map)))
        .where((recipe) => recipe.userId == user.id)
        .toList()
      ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
  }

  /// Get drink recipe by ID
  DrinkRecipe? getDrinkRecipe(String recipeId) {
    final json = _drinkRecipesBox.get(recipeId);
    if (json == null) return null;
    return DrinkRecipe.fromJson(Map<String, dynamic>.from(json as Map));
  }

  /// Search drink recipes by name
  List<DrinkRecipe> searchDrinkRecipes(String query) {
    final user = getCurrentUser();
    if (user == null) return [];

    final lowerQuery = query.toLowerCase();
    return _drinkRecipesBox.values
        .map((json) => DrinkRecipe.fromJson(Map<String, dynamic>.from(json as Map)))
        .where((recipe) =>
            recipe.userId == user.id &&
            recipe.name.toLowerCase().contains(lowerQuery))
        .toList()
      ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
  }

  /// Create new drink recipe
  Future<String> createDrinkRecipe(DrinkRecipe recipe) async {
    // Store as JSON until adapters are generated
    await _drinkRecipesBox.put(recipe.id, recipe.toJson());
    return recipe.id;
  }

  /// Update existing drink recipe
  Future<void> updateDrinkRecipe(DrinkRecipe recipe) async {
    recipe.touch();
    // Store as JSON until adapters are generated
    await _drinkRecipesBox.put(recipe.id, recipe.toJson());
  }

  /// Delete drink recipe
  Future<void> deleteDrinkRecipe(String recipeId) async {
    await _drinkRecipesBox.delete(recipeId);
  }

  /// Increment usage count for a drink recipe
  Future<void> incrementDrinkRecipeUsage(String recipeId) async {
    final recipe = getDrinkRecipe(recipeId);
    if (recipe == null) return;

    recipe.usageCount++;
    await updateDrinkRecipe(recipe);
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  /// Generate new UUID
  String generateId() => _uuid.v4();

  /// Clear all data (for testing or user logout)
  Future<void> clearAllData() async {
    await _userBox.clear();
    await _bagsBox.clear();
    await _cupsBox.clear();
    await _sharedCupsBox.clear();
    await _equipmentBox.clear();
    await _drinkRecipesBox.clear();
    await _createDefaultUser();
  }

  /// Get database statistics
  Map<String, int> getStats() {
    return {
      'users': _userBox.length,
      'bags': _bagsBox.length,
      'cups': _cupsBox.length,
      'sharedCups': _sharedCupsBox.length,
      'equipment': _equipmentBox.length,
      'drinkRecipes': _drinkRecipesBox.length,
    };
  }

  /// Close all boxes (call on app termination)
  Future<void> close() async {
    await _userBox.close();
    await _bagsBox.close();
    await _cupsBox.close();
    await _sharedCupsBox.close();
    await _equipmentBox.close();
    await _drinkRecipesBox.close();
  }
}

// Extension to make firstOrNull available if not using latest Dart
extension FirstWhereOrNullExtension<E> on Iterable<E> {
  E? get firstOrNull {
    final iterator = this.iterator;
    if (iterator.moveNext()) {
      return iterator.current;
    }
    return null;
  }
}
